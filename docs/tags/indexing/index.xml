<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Indexing on My New Hugo Site</title>
    <link>https://emlaver.github.io/gh-pages-example/tags/indexing/</link>
    <description>Recent content in Indexing on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://emlaver.github.io/gh-pages-example/tags/indexing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Indexing with the Cloudant Dashboard</title>
      <link>https://emlaver.github.io/gh-pages-example/2022/03/28/Indexing-with-the-Cloudant-Dashboard.html</link>
      <pubDate>Mon, 28 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://emlaver.github.io/gh-pages-example/2022/03/28/Indexing-with-the-Cloudant-Dashboard.html</guid>
      <description>The Cloudant dashboard gives new and experienced Cloudant users the opportunity to add, edit and delete documents while refining the indexing and querying options that best suit their application&amp;rsquo;s use-cases.
Photo by Zach Wiley on Unsplash
In this blog post we&amp;rsquo;ll set up some simple indexes using the dashboard and see how each of Cloudant&amp;rsquo;s querying mechanisms work.
The data set Let&amp;rsquo;s first create some sample data representing books in a library:</description>
    </item>
    
    <item>
      <title>Optimising Cloudant Queries</title>
      <link>https://emlaver.github.io/gh-pages-example/2020/05/20/Optimising-Cloudant-Queries.html</link>
      <pubDate>Fri, 24 Apr 2020 06:00:00 +0000</pubDate>
      
      <guid>https://emlaver.github.io/gh-pages-example/2020/05/20/Optimising-Cloudant-Queries.html</guid>
      <description>Cloudant Query is a JSON-based query language inspired by MongoDB. It allows the developer to express the slice of data they need from a database using a mixture of logical and comparison operators.
For example, if the following JSON is sent to the database&amp;rsquo;s _find endpoint:
POST /orders/_find { &amp;#34;selector&amp;#34;: { &amp;#34;$and&amp;#34;: [ { &amp;#34;date&amp;#34;: { &amp;#34;$gte&amp;#34;: &amp;#34;2018-01-01&amp;#34; } }, { &amp;#34;date&amp;#34;: { &amp;#34;$lt&amp;#34;: &amp;#34;2019-01-01&amp;#34; } }, { &amp;#34;status&amp;#34;: &amp;#34;cancelled&amp;#34; }, { &amp;#34;user&amp;#34;: &amp;#34;bob@aol.</description>
    </item>
    
    <item>
      <title>Optimal Cloudant Indexing</title>
      <link>https://emlaver.github.io/gh-pages-example/2019/05/10/Optimal-Cloudant-Indexing.html</link>
      <pubDate>Fri, 10 May 2019 06:00:00 +0000</pubDate>
      
      <guid>https://emlaver.github.io/gh-pages-example/2019/05/10/Optimal-Cloudant-Indexing.html</guid>
      <description>Traditionally, this is taught at Cloudant data modelling class:
Design JSON representations of the objects that exist in your application - products, users, orders etc. If necessary, create multiple document &amp;ldquo;types&amp;rdquo; in the same database - use a field in the document to differentiate one from the other e.g. &amp;quot;type&amp;quot;: &amp;quot;product&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;user&amp;quot; etc Build indexes on the fields which you are going to query against e.g. if I am going to search products by category in product name order, I&amp;rsquo;m going to need an index on category &amp;amp; name.</description>
    </item>
    
    <item>
      <title>Partitioned Databases - Data Design</title>
      <link>https://emlaver.github.io/gh-pages-example/2019/03/05/Partition-Databases-Data-Design.html</link>
      <pubDate>Tue, 05 Mar 2019 07:00:00 +0000</pubDate>
      
      <guid>https://emlaver.github.io/gh-pages-example/2019/03/05/Partition-Databases-Data-Design.html</guid>
      <description>This is the second part of a series of posts on Partitioned Databases in Cloudant. Part One, Part Three and Part Four may also be of interest.
Modelling data with a JSON document store is very different from modelling data in a relational database system. Generations of computer scientists have been taught how to normalize data into tables, that is organising data into their own collections so that information is not repeated and relationships between collections are modelled with foreign keys.</description>
    </item>
    
    <item>
      <title>Stale, update and stable</title>
      <link>https://emlaver.github.io/gh-pages-example/2018/11/06/What-is-stale-update-and-stable.html</link>
      <pubDate>Tue, 06 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://emlaver.github.io/gh-pages-example/2018/11/06/What-is-stale-update-and-stable.html</guid>
      <description>tl;dr If you are using stale=ok in queries to Cloudant or CouchDB 2.x, you most likely want to be using update=false instead. If you are using stale=update_after, use update=lazy instead.
This question has come up a few times, so here&amp;rsquo;s a reference to what the situation is with these parameters to query requests in Cloudant and CouchDB 2.x.
CouchDB originally used stale=ok on the query string to specify that you were okay with receiving out-of-date results.</description>
    </item>
    
    <item>
      <title>Time-sortable _ids</title>
      <link>https://emlaver.github.io/gh-pages-example/2018/08/24/Time-sortable-document-ids.html</link>
      <pubDate>Fri, 24 Aug 2018 06:00:00 +0000</pubDate>
      
      <guid>https://emlaver.github.io/gh-pages-example/2018/08/24/Time-sortable-document-ids.html</guid>
      <description>A Cloudant database document&amp;rsquo;s _id field has to be unique. When you create a document and leave the _id field blank, the database will create one for you:
curl -X POST \ -d&amp;#39;{&amp;#34;x&amp;#34;:1}&amp;#39; \ -H &amp;#39;Content-type: application/json&amp;#39; &amp;#34;https://USERNAME:PASSWORD@HOST.cloudant.com/mydb&amp;#34; {&amp;#34;ok&amp;#34;:true,&amp;#34;id&amp;#34;:&amp;#34;97728a06c27d1e11378cd43635c98c1e&amp;#34;,&amp;#34;rev&amp;#34;:&amp;#34;1-0785e9eb543380151003dc452c3a001a&amp;#34;} Cloudant&amp;rsquo;s generated _id fields are 32 characters long and made entirely of numerals and lowercase letters. They are unique, or at least have a negligible probability of clashing, by virtue of being a long pseudo-random string of characters.</description>
    </item>
    
    <item>
      <title>Cloudant Fundamentals 9/10</title>
      <link>https://emlaver.github.io/gh-pages-example/2018/07/12/CloudantFundamentals-Indexing.html</link>
      <pubDate>Thu, 12 Jul 2018 06:00:00 +0000</pubDate>
      
      <guid>https://emlaver.github.io/gh-pages-example/2018/07/12/CloudantFundamentals-Indexing.html</guid>
      <description>In part 7 of this series, we saw a warning in the search results:
&amp;ldquo;no matching index found, create an index to optimize query time&amp;rdquo;
This is Cloudant&amp;rsquo;s polite way of saying that your query is expensive and the database is having to walk through the whole data set to calculate the answer. In small databases this is not a problem but in a production system, with the data growing all the time, an index is essential.</description>
    </item>
    
    <item>
      <title>Partial Indexes</title>
      <link>https://emlaver.github.io/gh-pages-example/2018/01/10/Partial-Indexes.html</link>
      <pubDate>Wed, 10 Jan 2018 09:00:00 +0000</pubDate>
      
      <guid>https://emlaver.github.io/gh-pages-example/2018/01/10/Partial-Indexes.html</guid>
      <description>Indexing is what makes database queries fast and scalable. Without and index, a database is forced to trawl through every record to calculate the answer to a query. A carefully designed index allows a query to be answered with a fraction of a work by jumping to the pertinent portion.
Image by Jay Wennington
Indexing basics Let&amp;rsquo;s dive in with the example of road safety data from the UK government&amp;rsquo;s open data portal.</description>
    </item>
    
    <item>
      <title>Custom Indexers</title>
      <link>https://emlaver.github.io/gh-pages-example/2017/09/26/Custom-indexers-for-Cloudant.html</link>
      <pubDate>Tue, 26 Sep 2017 09:00:00 +0000</pubDate>
      
      <guid>https://emlaver.github.io/gh-pages-example/2017/09/26/Custom-indexers-for-Cloudant.html</guid>
      <description>Cloudant offers highly available storage and retrieval of JSON documents across a cluster of computing which includes a primary index on the documents&amp;rsquo; _id field. You can also use the same cluster to power secondary indexes built to provide selection &amp;amp; aggregation using MapReduce, full-text search using Apache Lucene, or GeoSpatial queries.
What if you want something a little different that isn&amp;rsquo;t supported by the built-in indexers? You can build you own!</description>
    </item>
    
  </channel>
</rss>
